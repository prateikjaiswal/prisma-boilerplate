// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateClient {
  count: Int!
}

type AggregateCost {
  count: Int!
}

type AggregateCostType {
  count: Int!
}

type AggregateProject {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Client {
  ID: ID!
  name: String
  projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project!]
}

type ClientConnection {
  pageInfo: PageInfo!
  edges: [ClientEdge]!
  aggregate: AggregateClient!
}

input ClientCreateInput {
  ID: ID
  name: String
  projects: ProjectCreateManyWithoutClientInput
}

input ClientCreateOneWithoutProjectsInput {
  create: ClientCreateWithoutProjectsInput
  connect: ClientWhereUniqueInput
}

input ClientCreateWithoutProjectsInput {
  ID: ID
  name: String
}

type ClientEdge {
  node: Client!
  cursor: String!
}

enum ClientOrderByInput {
  ID_ASC
  ID_DESC
  name_ASC
  name_DESC
}

type ClientPreviousValues {
  ID: ID!
  name: String
}

type ClientSubscriptionPayload {
  mutation: MutationType!
  node: Client
  updatedFields: [String!]
  previousValues: ClientPreviousValues
}

input ClientSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClientWhereInput
  AND: [ClientSubscriptionWhereInput!]
  OR: [ClientSubscriptionWhereInput!]
  NOT: [ClientSubscriptionWhereInput!]
}

input ClientUpdateInput {
  name: String
  projects: ProjectUpdateManyWithoutClientInput
}

input ClientUpdateManyMutationInput {
  name: String
}

input ClientUpdateOneWithoutProjectsInput {
  create: ClientCreateWithoutProjectsInput
  update: ClientUpdateWithoutProjectsDataInput
  upsert: ClientUpsertWithoutProjectsInput
  delete: Boolean
  disconnect: Boolean
  connect: ClientWhereUniqueInput
}

input ClientUpdateWithoutProjectsDataInput {
  name: String
}

input ClientUpsertWithoutProjectsInput {
  update: ClientUpdateWithoutProjectsDataInput!
  create: ClientCreateWithoutProjectsInput!
}

input ClientWhereInput {
  ID: ID
  ID_not: ID
  ID_in: [ID!]
  ID_not_in: [ID!]
  ID_lt: ID
  ID_lte: ID
  ID_gt: ID
  ID_gte: ID
  ID_contains: ID
  ID_not_contains: ID
  ID_starts_with: ID
  ID_not_starts_with: ID
  ID_ends_with: ID
  ID_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  projects_every: ProjectWhereInput
  projects_some: ProjectWhereInput
  projects_none: ProjectWhereInput
  AND: [ClientWhereInput!]
  OR: [ClientWhereInput!]
  NOT: [ClientWhereInput!]
}

input ClientWhereUniqueInput {
  ID: ID
}

type Cost {
  ID: ID!
  amount: Float
  costType: CostType
  project: Project
}

type CostConnection {
  pageInfo: PageInfo!
  edges: [CostEdge]!
  aggregate: AggregateCost!
}

input CostCreateInput {
  ID: ID
  amount: Float
  costType: CostTypeCreateOneWithoutCostsInput
  project: ProjectCreateOneWithoutCostsInput
}

input CostCreateManyWithoutCostTypeInput {
  create: [CostCreateWithoutCostTypeInput!]
  connect: [CostWhereUniqueInput!]
}

input CostCreateManyWithoutProjectInput {
  create: [CostCreateWithoutProjectInput!]
  connect: [CostWhereUniqueInput!]
}

input CostCreateWithoutCostTypeInput {
  ID: ID
  amount: Float
  project: ProjectCreateOneWithoutCostsInput
}

input CostCreateWithoutProjectInput {
  ID: ID
  amount: Float
  costType: CostTypeCreateOneWithoutCostsInput
}

type CostEdge {
  node: Cost!
  cursor: String!
}

enum CostOrderByInput {
  ID_ASC
  ID_DESC
  amount_ASC
  amount_DESC
}

type CostPreviousValues {
  ID: ID!
  amount: Float
}

input CostScalarWhereInput {
  ID: ID
  ID_not: ID
  ID_in: [ID!]
  ID_not_in: [ID!]
  ID_lt: ID
  ID_lte: ID
  ID_gt: ID
  ID_gte: ID
  ID_contains: ID
  ID_not_contains: ID
  ID_starts_with: ID
  ID_not_starts_with: ID
  ID_ends_with: ID
  ID_not_ends_with: ID
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  AND: [CostScalarWhereInput!]
  OR: [CostScalarWhereInput!]
  NOT: [CostScalarWhereInput!]
}

type CostSubscriptionPayload {
  mutation: MutationType!
  node: Cost
  updatedFields: [String!]
  previousValues: CostPreviousValues
}

input CostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CostWhereInput
  AND: [CostSubscriptionWhereInput!]
  OR: [CostSubscriptionWhereInput!]
  NOT: [CostSubscriptionWhereInput!]
}

type CostType {
  ID: ID!
  costs(where: CostWhereInput, orderBy: CostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Cost!]
  costTypes(where: CostTypeWhereInput, orderBy: CostTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CostType!]
  name: String
  parentCostType: CostType
}

type CostTypeConnection {
  pageInfo: PageInfo!
  edges: [CostTypeEdge]!
  aggregate: AggregateCostType!
}

input CostTypeCreateInput {
  ID: ID
  costs: CostCreateManyWithoutCostTypeInput
  costTypes: CostTypeCreateManyWithoutCostTypesInput
  name: String
  parentCostType: CostTypeCreateOneWithoutParentCostTypeInput
}

input CostTypeCreateManyWithoutCostTypesInput {
  create: [CostTypeCreateWithoutCostTypesInput!]
  connect: [CostTypeWhereUniqueInput!]
}

input CostTypeCreateOneWithoutCostsInput {
  create: CostTypeCreateWithoutCostsInput
  connect: CostTypeWhereUniqueInput
}

input CostTypeCreateOneWithoutParentCostTypeInput {
  create: CostTypeCreateWithoutParentCostTypeInput
  connect: CostTypeWhereUniqueInput
}

input CostTypeCreateWithoutCostsInput {
  ID: ID
  costTypes: CostTypeCreateManyWithoutCostTypesInput
  name: String
  parentCostType: CostTypeCreateOneWithoutParentCostTypeInput
}

input CostTypeCreateWithoutCostTypesInput {
  ID: ID
  costs: CostCreateManyWithoutCostTypeInput
  name: String
  parentCostType: CostTypeCreateOneWithoutParentCostTypeInput
}

input CostTypeCreateWithoutParentCostTypeInput {
  ID: ID
  costs: CostCreateManyWithoutCostTypeInput
  costTypes: CostTypeCreateManyWithoutCostTypesInput
  name: String
}

type CostTypeEdge {
  node: CostType!
  cursor: String!
}

enum CostTypeOrderByInput {
  ID_ASC
  ID_DESC
  name_ASC
  name_DESC
}

type CostTypePreviousValues {
  ID: ID!
  name: String
}

input CostTypeScalarWhereInput {
  ID: ID
  ID_not: ID
  ID_in: [ID!]
  ID_not_in: [ID!]
  ID_lt: ID
  ID_lte: ID
  ID_gt: ID
  ID_gte: ID
  ID_contains: ID
  ID_not_contains: ID
  ID_starts_with: ID
  ID_not_starts_with: ID
  ID_ends_with: ID
  ID_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [CostTypeScalarWhereInput!]
  OR: [CostTypeScalarWhereInput!]
  NOT: [CostTypeScalarWhereInput!]
}

type CostTypeSubscriptionPayload {
  mutation: MutationType!
  node: CostType
  updatedFields: [String!]
  previousValues: CostTypePreviousValues
}

input CostTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CostTypeWhereInput
  AND: [CostTypeSubscriptionWhereInput!]
  OR: [CostTypeSubscriptionWhereInput!]
  NOT: [CostTypeSubscriptionWhereInput!]
}

input CostTypeUpdateInput {
  costs: CostUpdateManyWithoutCostTypeInput
  costTypes: CostTypeUpdateManyWithoutCostTypesInput
  name: String
  parentCostType: CostTypeUpdateOneWithoutParentCostTypeInput
}

input CostTypeUpdateManyDataInput {
  name: String
}

input CostTypeUpdateManyMutationInput {
  name: String
}

input CostTypeUpdateManyWithoutCostTypesInput {
  create: [CostTypeCreateWithoutCostTypesInput!]
  delete: [CostTypeWhereUniqueInput!]
  connect: [CostTypeWhereUniqueInput!]
  set: [CostTypeWhereUniqueInput!]
  disconnect: [CostTypeWhereUniqueInput!]
  update: [CostTypeUpdateWithWhereUniqueWithoutCostTypesInput!]
  upsert: [CostTypeUpsertWithWhereUniqueWithoutCostTypesInput!]
  deleteMany: [CostTypeScalarWhereInput!]
  updateMany: [CostTypeUpdateManyWithWhereNestedInput!]
}

input CostTypeUpdateManyWithWhereNestedInput {
  where: CostTypeScalarWhereInput!
  data: CostTypeUpdateManyDataInput!
}

input CostTypeUpdateOneWithoutCostsInput {
  create: CostTypeCreateWithoutCostsInput
  update: CostTypeUpdateWithoutCostsDataInput
  upsert: CostTypeUpsertWithoutCostsInput
  delete: Boolean
  disconnect: Boolean
  connect: CostTypeWhereUniqueInput
}

input CostTypeUpdateOneWithoutParentCostTypeInput {
  create: CostTypeCreateWithoutParentCostTypeInput
  update: CostTypeUpdateWithoutParentCostTypeDataInput
  upsert: CostTypeUpsertWithoutParentCostTypeInput
  delete: Boolean
  disconnect: Boolean
  connect: CostTypeWhereUniqueInput
}

input CostTypeUpdateWithoutCostsDataInput {
  costTypes: CostTypeUpdateManyWithoutCostTypesInput
  name: String
  parentCostType: CostTypeUpdateOneWithoutParentCostTypeInput
}

input CostTypeUpdateWithoutCostTypesDataInput {
  costs: CostUpdateManyWithoutCostTypeInput
  name: String
  parentCostType: CostTypeUpdateOneWithoutParentCostTypeInput
}

input CostTypeUpdateWithoutParentCostTypeDataInput {
  costs: CostUpdateManyWithoutCostTypeInput
  costTypes: CostTypeUpdateManyWithoutCostTypesInput
  name: String
}

input CostTypeUpdateWithWhereUniqueWithoutCostTypesInput {
  where: CostTypeWhereUniqueInput!
  data: CostTypeUpdateWithoutCostTypesDataInput!
}

input CostTypeUpsertWithoutCostsInput {
  update: CostTypeUpdateWithoutCostsDataInput!
  create: CostTypeCreateWithoutCostsInput!
}

input CostTypeUpsertWithoutParentCostTypeInput {
  update: CostTypeUpdateWithoutParentCostTypeDataInput!
  create: CostTypeCreateWithoutParentCostTypeInput!
}

input CostTypeUpsertWithWhereUniqueWithoutCostTypesInput {
  where: CostTypeWhereUniqueInput!
  update: CostTypeUpdateWithoutCostTypesDataInput!
  create: CostTypeCreateWithoutCostTypesInput!
}

input CostTypeWhereInput {
  ID: ID
  ID_not: ID
  ID_in: [ID!]
  ID_not_in: [ID!]
  ID_lt: ID
  ID_lte: ID
  ID_gt: ID
  ID_gte: ID
  ID_contains: ID
  ID_not_contains: ID
  ID_starts_with: ID
  ID_not_starts_with: ID
  ID_ends_with: ID
  ID_not_ends_with: ID
  costs_every: CostWhereInput
  costs_some: CostWhereInput
  costs_none: CostWhereInput
  costTypes_every: CostTypeWhereInput
  costTypes_some: CostTypeWhereInput
  costTypes_none: CostTypeWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  parentCostType: CostTypeWhereInput
  AND: [CostTypeWhereInput!]
  OR: [CostTypeWhereInput!]
  NOT: [CostTypeWhereInput!]
}

input CostTypeWhereUniqueInput {
  ID: ID
}

input CostUpdateInput {
  amount: Float
  costType: CostTypeUpdateOneWithoutCostsInput
  project: ProjectUpdateOneWithoutCostsInput
}

input CostUpdateManyDataInput {
  amount: Float
}

input CostUpdateManyMutationInput {
  amount: Float
}

input CostUpdateManyWithoutCostTypeInput {
  create: [CostCreateWithoutCostTypeInput!]
  delete: [CostWhereUniqueInput!]
  connect: [CostWhereUniqueInput!]
  set: [CostWhereUniqueInput!]
  disconnect: [CostWhereUniqueInput!]
  update: [CostUpdateWithWhereUniqueWithoutCostTypeInput!]
  upsert: [CostUpsertWithWhereUniqueWithoutCostTypeInput!]
  deleteMany: [CostScalarWhereInput!]
  updateMany: [CostUpdateManyWithWhereNestedInput!]
}

input CostUpdateManyWithoutProjectInput {
  create: [CostCreateWithoutProjectInput!]
  delete: [CostWhereUniqueInput!]
  connect: [CostWhereUniqueInput!]
  set: [CostWhereUniqueInput!]
  disconnect: [CostWhereUniqueInput!]
  update: [CostUpdateWithWhereUniqueWithoutProjectInput!]
  upsert: [CostUpsertWithWhereUniqueWithoutProjectInput!]
  deleteMany: [CostScalarWhereInput!]
  updateMany: [CostUpdateManyWithWhereNestedInput!]
}

input CostUpdateManyWithWhereNestedInput {
  where: CostScalarWhereInput!
  data: CostUpdateManyDataInput!
}

input CostUpdateWithoutCostTypeDataInput {
  amount: Float
  project: ProjectUpdateOneWithoutCostsInput
}

input CostUpdateWithoutProjectDataInput {
  amount: Float
  costType: CostTypeUpdateOneWithoutCostsInput
}

input CostUpdateWithWhereUniqueWithoutCostTypeInput {
  where: CostWhereUniqueInput!
  data: CostUpdateWithoutCostTypeDataInput!
}

input CostUpdateWithWhereUniqueWithoutProjectInput {
  where: CostWhereUniqueInput!
  data: CostUpdateWithoutProjectDataInput!
}

input CostUpsertWithWhereUniqueWithoutCostTypeInput {
  where: CostWhereUniqueInput!
  update: CostUpdateWithoutCostTypeDataInput!
  create: CostCreateWithoutCostTypeInput!
}

input CostUpsertWithWhereUniqueWithoutProjectInput {
  where: CostWhereUniqueInput!
  update: CostUpdateWithoutProjectDataInput!
  create: CostCreateWithoutProjectInput!
}

input CostWhereInput {
  ID: ID
  ID_not: ID
  ID_in: [ID!]
  ID_not_in: [ID!]
  ID_lt: ID
  ID_lte: ID
  ID_gt: ID
  ID_gte: ID
  ID_contains: ID
  ID_not_contains: ID
  ID_starts_with: ID
  ID_not_starts_with: ID
  ID_ends_with: ID
  ID_not_ends_with: ID
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  costType: CostTypeWhereInput
  project: ProjectWhereInput
  AND: [CostWhereInput!]
  OR: [CostWhereInput!]
  NOT: [CostWhereInput!]
}

input CostWhereUniqueInput {
  ID: ID
}

scalar Long

type Mutation {
  createClient(data: ClientCreateInput!): Client!
  updateClient(data: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client
  updateManyClients(data: ClientUpdateManyMutationInput!, where: ClientWhereInput): BatchPayload!
  upsertClient(where: ClientWhereUniqueInput!, create: ClientCreateInput!, update: ClientUpdateInput!): Client!
  deleteClient(where: ClientWhereUniqueInput!): Client
  deleteManyClients(where: ClientWhereInput): BatchPayload!
  createCost(data: CostCreateInput!): Cost!
  updateCost(data: CostUpdateInput!, where: CostWhereUniqueInput!): Cost
  updateManyCosts(data: CostUpdateManyMutationInput!, where: CostWhereInput): BatchPayload!
  upsertCost(where: CostWhereUniqueInput!, create: CostCreateInput!, update: CostUpdateInput!): Cost!
  deleteCost(where: CostWhereUniqueInput!): Cost
  deleteManyCosts(where: CostWhereInput): BatchPayload!
  createCostType(data: CostTypeCreateInput!): CostType!
  updateCostType(data: CostTypeUpdateInput!, where: CostTypeWhereUniqueInput!): CostType
  updateManyCostTypes(data: CostTypeUpdateManyMutationInput!, where: CostTypeWhereInput): BatchPayload!
  upsertCostType(where: CostTypeWhereUniqueInput!, create: CostTypeCreateInput!, update: CostTypeUpdateInput!): CostType!
  deleteCostType(where: CostTypeWhereUniqueInput!): CostType
  deleteManyCostTypes(where: CostTypeWhereInput): BatchPayload!
  createProject(data: ProjectCreateInput!): Project!
  updateProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateManyProjects(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): BatchPayload!
  upsertProject(where: ProjectWhereUniqueInput!, create: ProjectCreateInput!, update: ProjectUpdateInput!): Project!
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteManyProjects(where: ProjectWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Project {
  ID: ID!
  client: Client
  costs(where: CostWhereInput, orderBy: CostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Cost!]
  title: String
}

type ProjectConnection {
  pageInfo: PageInfo!
  edges: [ProjectEdge]!
  aggregate: AggregateProject!
}

input ProjectCreateInput {
  ID: ID
  client: ClientCreateOneWithoutProjectsInput
  costs: CostCreateManyWithoutProjectInput
  title: String
}

input ProjectCreateManyWithoutClientInput {
  create: [ProjectCreateWithoutClientInput!]
  connect: [ProjectWhereUniqueInput!]
}

input ProjectCreateOneWithoutCostsInput {
  create: ProjectCreateWithoutCostsInput
  connect: ProjectWhereUniqueInput
}

input ProjectCreateWithoutClientInput {
  ID: ID
  costs: CostCreateManyWithoutProjectInput
  title: String
}

input ProjectCreateWithoutCostsInput {
  ID: ID
  client: ClientCreateOneWithoutProjectsInput
  title: String
}

type ProjectEdge {
  node: Project!
  cursor: String!
}

enum ProjectOrderByInput {
  ID_ASC
  ID_DESC
  title_ASC
  title_DESC
}

type ProjectPreviousValues {
  ID: ID!
  title: String
}

input ProjectScalarWhereInput {
  ID: ID
  ID_not: ID
  ID_in: [ID!]
  ID_not_in: [ID!]
  ID_lt: ID
  ID_lte: ID
  ID_gt: ID
  ID_gte: ID
  ID_contains: ID
  ID_not_contains: ID
  ID_starts_with: ID
  ID_not_starts_with: ID
  ID_ends_with: ID
  ID_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [ProjectScalarWhereInput!]
  OR: [ProjectScalarWhereInput!]
  NOT: [ProjectScalarWhereInput!]
}

type ProjectSubscriptionPayload {
  mutation: MutationType!
  node: Project
  updatedFields: [String!]
  previousValues: ProjectPreviousValues
}

input ProjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProjectWhereInput
  AND: [ProjectSubscriptionWhereInput!]
  OR: [ProjectSubscriptionWhereInput!]
  NOT: [ProjectSubscriptionWhereInput!]
}

input ProjectUpdateInput {
  client: ClientUpdateOneWithoutProjectsInput
  costs: CostUpdateManyWithoutProjectInput
  title: String
}

input ProjectUpdateManyDataInput {
  title: String
}

input ProjectUpdateManyMutationInput {
  title: String
}

input ProjectUpdateManyWithoutClientInput {
  create: [ProjectCreateWithoutClientInput!]
  delete: [ProjectWhereUniqueInput!]
  connect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  disconnect: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutClientInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutClientInput!]
  deleteMany: [ProjectScalarWhereInput!]
  updateMany: [ProjectUpdateManyWithWhereNestedInput!]
}

input ProjectUpdateManyWithWhereNestedInput {
  where: ProjectScalarWhereInput!
  data: ProjectUpdateManyDataInput!
}

input ProjectUpdateOneWithoutCostsInput {
  create: ProjectCreateWithoutCostsInput
  update: ProjectUpdateWithoutCostsDataInput
  upsert: ProjectUpsertWithoutCostsInput
  delete: Boolean
  disconnect: Boolean
  connect: ProjectWhereUniqueInput
}

input ProjectUpdateWithoutClientDataInput {
  costs: CostUpdateManyWithoutProjectInput
  title: String
}

input ProjectUpdateWithoutCostsDataInput {
  client: ClientUpdateOneWithoutProjectsInput
  title: String
}

input ProjectUpdateWithWhereUniqueWithoutClientInput {
  where: ProjectWhereUniqueInput!
  data: ProjectUpdateWithoutClientDataInput!
}

input ProjectUpsertWithoutCostsInput {
  update: ProjectUpdateWithoutCostsDataInput!
  create: ProjectCreateWithoutCostsInput!
}

input ProjectUpsertWithWhereUniqueWithoutClientInput {
  where: ProjectWhereUniqueInput!
  update: ProjectUpdateWithoutClientDataInput!
  create: ProjectCreateWithoutClientInput!
}

input ProjectWhereInput {
  ID: ID
  ID_not: ID
  ID_in: [ID!]
  ID_not_in: [ID!]
  ID_lt: ID
  ID_lte: ID
  ID_gt: ID
  ID_gte: ID
  ID_contains: ID
  ID_not_contains: ID
  ID_starts_with: ID
  ID_not_starts_with: ID
  ID_ends_with: ID
  ID_not_ends_with: ID
  client: ClientWhereInput
  costs_every: CostWhereInput
  costs_some: CostWhereInput
  costs_none: CostWhereInput
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
}

input ProjectWhereUniqueInput {
  ID: ID
}

type Query {
  client(where: ClientWhereUniqueInput!): Client
  clients(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Client]!
  clientsConnection(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClientConnection!
  cost(where: CostWhereUniqueInput!): Cost
  costs(where: CostWhereInput, orderBy: CostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Cost]!
  costsConnection(where: CostWhereInput, orderBy: CostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CostConnection!
  costType(where: CostTypeWhereUniqueInput!): CostType
  costTypes(where: CostTypeWhereInput, orderBy: CostTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CostType]!
  costTypesConnection(where: CostTypeWhereInput, orderBy: CostTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CostTypeConnection!
  project(where: ProjectWhereUniqueInput!): Project
  projects(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Project]!
  projectsConnection(where: ProjectWhereInput, orderBy: ProjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProjectConnection!
  node(id: ID!): Node
}

type Subscription {
  client(where: ClientSubscriptionWhereInput): ClientSubscriptionPayload
  cost(where: CostSubscriptionWhereInput): CostSubscriptionPayload
  costType(where: CostTypeSubscriptionWhereInput): CostTypeSubscriptionPayload
  project(where: ProjectSubscriptionWhereInput): ProjectSubscriptionPayload
}
`